// Servi√ßo de API integrado com Firebase Firestore
import { db } from '../firebase/config';
import { 
  collection, 
  getDocs, 
  addDoc, 
  doc, 
  updateDoc, 
  deleteDoc, 
  query, 
  orderBy, 
  where,
  limit,
  startAfter,
  endBefore,
  limitToLast
} from 'firebase/firestore';
import { toast } from 'react-toastify';

// API para transa√ß√µes (usando Firebase Firestore)
export const transactionsAPI = {
  getTransactions: async (params?: any) => {
    try {
      console.log('üî• Buscando transa√ß√µes no Firestore...');
      const transactionsRef = collection(db, 'transactions');
      const q = query(transactionsRef, orderBy('created_at', 'desc'));
      const querySnapshot = await getDocs(q);
      
      const transactions = querySnapshot.docs.map(doc => ({
        id: parseInt(doc.id) || Math.random() * 1000000, // Converter para number
        description: doc.data().description || 'Descri√ß√£o n√£o informada',
        amount: doc.data().amount || 0,
        type: doc.data().type || 'income',
        transaction_date: doc.data().transaction_date || new Date(),
        category_id: doc.data().category_id || '',
        member_id: doc.data().member_id || '',
        payment_method: doc.data().payment_method || 'cash',
        created_at: doc.data().created_at || new Date(),
        updated_at: doc.data().updated_at || new Date()
      }));
      
      console.log('‚úÖ Transa√ß√µes carregadas do Firestore:', transactions.length);
      return { data: { transactions, total: transactions.length } };
    } catch (error) {
      console.error('‚ùå Erro ao buscar transa√ß√µes:', error);
      return { data: { transactions: [], total: 0 } };
    }
  },

  createTransaction: async (data: any) => {
    try {
      console.log('üíæ Salvando transa√ß√£o no Firestore:', data);
      console.log('üî• Firebase DB instance:', db);
      
      const transactionData = {
        ...data,
        created_at: new Date(),
        updated_at: new Date()
      };
      
      console.log('üìù Dados da transa√ß√£o preparados:', transactionData);
      
      const transactionsRef = collection(db, 'transactions');
      console.log('üìÇ Refer√™ncia da cole√ß√£o criada:', transactionsRef);
      
      const docRef = await addDoc(transactionsRef, transactionData);
      console.log('‚úÖ Transa√ß√£o salva no Firestore com ID:', docRef.id);
      
      return {
        data: {
          message: 'Transa√ß√£o criada com sucesso',
          transaction: { id: docRef.id, ...transactionData }
        }
      };
    } catch (error: any) {
      console.error('‚ùå Erro ao criar transa√ß√£o:', error);
      console.error('‚ùå Detalhes do erro:', error.message);
      console.error('‚ùå Stack trace:', error.stack);
      toast.error('Erro ao salvar transa√ß√£o: ' + error.message);
      throw error;
    }
  },

  updateTransaction: async (id: string, data: any) => {
    try {
      console.log('üîÑ Atualizando transa√ß√£o no Firestore:', id);
      
      const transactionRef = doc(db, 'transactions', id);
      await updateDoc(transactionRef, {
        ...data,
        updated_at: new Date()
      });
      
      console.log('‚úÖ Transa√ß√£o atualizada no Firestore');
      return { data: { message: 'Transa√ß√£o atualizada com sucesso' } };
    } catch (error) {
      console.error('‚ùå Erro ao atualizar transa√ß√£o:', error);
      toast.error('Erro ao atualizar transa√ß√£o');
      throw error;
    }
  },

  deleteTransaction: async (id: string) => {
    try {
      console.log('üóëÔ∏è Deletando transa√ß√£o do Firestore:', id);
      console.log('üîç Tipo do ID:', typeof id);
      console.log('üîç Valor do ID:', id);
      
      const transactionRef = doc(db, 'transactions', id);
      console.log('üìÇ Refer√™ncia criada:', transactionRef);
      
      await deleteDoc(transactionRef);
      
      console.log('‚úÖ Transa√ß√£o deletada do Firestore com sucesso');
      return { data: { message: 'Transa√ß√£o deletada com sucesso' } };
    } catch (error) {
      console.error('‚ùå Erro ao deletar transa√ß√£o:', error);
      console.error('‚ùå Detalhes do erro:', error);
      toast.error('Erro ao deletar transa√ß√£o: ' + (error as Error).message);
      throw error;
    }
  },

  getSummary: async () => {
    try {
      console.log('üìä Calculando resumo financeiro...');
      const transactionsRef = collection(db, 'transactions');
      const querySnapshot = await getDocs(transactionsRef);
      
      let totalIncome = 0;
      let totalExpense = 0;
      
      querySnapshot.docs.forEach(doc => {
        const data = doc.data();
        if (data.type === 'income') {
          totalIncome += parseFloat(data.amount) || 0;
        } else if (data.type === 'expense') {
          totalExpense += parseFloat(data.amount) || 0;
        }
      });
      
      const summary = {
        totalIncome,
        totalExpense,
        balance: totalIncome - totalExpense,
        transactionCount: querySnapshot.docs.length
      };
      
      console.log('‚úÖ Resumo calculado:', summary);
      return { data: summary };
    } catch (error) {
      console.error('‚ùå Erro ao calcular resumo:', error);
      return { data: { totalIncome: 0, totalExpense: 0, balance: 0, transactionCount: 0 } };
    }
  },

  getTransaction: async (id: string) => {
    try {
      const transactionRef = doc(db, 'transactions', id);
      const transactionDoc = await getDocs(collection(db, 'transactions'));
      const transaction = transactionDoc.docs.find(doc => doc.id === id);
      
      if (!transaction) {
        throw new Error('Transa√ß√£o n√£o encontrada');
      }
      
      return { data: { id: transaction.id, ...transaction.data() } };
    } catch (error) {
      console.error('‚ùå Erro ao buscar transa√ß√£o:', error);
      throw error;
    }
  },

  getByCategory: async (params?: any) => {
    return { data: { transactions: [], total: 0 } };
  },

  getCashFlow: async (params?: any) => {
    return { data: { cashFlow: [] } };
  }
};

// API para membros (usando Firebase Firestore)
export const membersAPI = {
  getMembers: async () => {
    try {
      console.log('üî• Buscando membros no Firestore...');
      const membersRef = collection(db, 'members');
      const q = query(membersRef, orderBy('created_at', 'desc'));
      const querySnapshot = await getDocs(q);
      
      const members = querySnapshot.docs.map(doc => ({
        id: parseInt(doc.id) || Math.random() * 1000000, // Converter para number
        name: doc.data().name || 'Nome n√£o informado',
        email: doc.data().email || '',
        phone: doc.data().phone || '',
        status: doc.data().status || 'active',
        created_at: doc.data().created_at || new Date(),
        updated_at: doc.data().updated_at || new Date()
      }));
      
      console.log('‚úÖ Membro carregados do Firestore:', members.length);
      return { data: { members, total: members.length } };
    } catch (error) {
      console.error('‚ùå Erro ao buscar membros:', error);
      return { data: { members: [], total: 0 } };
    }
  },

  createMember: async (data: any) => {
    try {
      console.log('üíæ Salvando membro no Firestore:', data);
      console.log('üî• Firebase DB instance:', db);
      
      const memberData = {
        ...data,
        created_at: new Date(),
        updated_at: new Date()
      };
      
      console.log('üìù Dados do membro preparados:', memberData);
      
      const membersRef = collection(db, 'members');
      console.log('üìÇ Refer√™ncia da cole√ß√£o criada:', membersRef);
      
      const docRef = await addDoc(membersRef, memberData);
      console.log('‚úÖ Membro salvo no Firestore com ID:', docRef.id);
      
      return {
        data: {
          message: 'Membro criado com sucesso',
          member: { id: docRef.id, ...memberData }
        }
      };
    } catch (error: any) {
      console.error('‚ùå Erro ao criar membro:', error);
      console.error('‚ùå Detalhes do erro:', error.message);
      console.error('‚ùå Stack trace:', error.stack);
      toast.error('Erro ao salvar membro: ' + error.message);
      throw error;
    }
  },

  updateMember: async (id: string, data: any) => {
    try {
      console.log('üîÑ Atualizando membro no Firestore:', id);
      
      const memberRef = doc(db, 'members', id);
      await updateDoc(memberRef, {
        ...data,
        updated_at: new Date()
      });
      
      console.log('‚úÖ Membro atualizado no Firestore');
      return { data: { message: 'Membro atualizado com sucesso' } };
    } catch (error) {
      console.error('‚ùå Erro ao atualizar membro:', error);
      toast.error('Erro ao atualizar membro');
      throw error;
    }
  },

  deleteMember: async (id: string) => {
    try {
      console.log('üóëÔ∏è Deletando membro do Firestore:', id);
      console.log('üîç Tipo do ID:', typeof id);
      console.log('üîç Valor do ID:', id);
      
      const memberRef = doc(db, 'members', id);
      console.log('üìÇ Refer√™ncia criada:', memberRef);
      
      await deleteDoc(memberRef);
      
      console.log('‚úÖ Membro deletado do Firestore com sucesso');
      return { data: { message: 'Membro deletado com sucesso' } };
    } catch (error) {
      console.error('‚ùå Erro ao deletar membro:', error);
      console.error('‚ùå Detalhes do erro:', error);
      toast.error('Erro ao deletar membro: ' + (error as Error).message);
      throw error;
    }
  },

  getMember: async (id: string) => {
    try {
      const membersRef = collection(db, 'members');
      const querySnapshot = await getDocs(membersRef);
      const member = querySnapshot.docs.find(doc => doc.id === id);
      
      if (!member) {
        throw new Error('Membro n√£o encontrado');
      }
      
      return { data: { id: member.id, ...member.data() } };
    } catch (error) {
      console.error('‚ùå Erro ao buscar membro:', error);
      throw error;
    }
  },

  getMemberStats: async () => {
    try {
      console.log('üìä Calculando estat√≠sticas de membros...');
      const membersRef = collection(db, 'members');
      const querySnapshot = await getDocs(membersRef);
      
      const stats = {
        total: querySnapshot.docs.length,
        active: querySnapshot.docs.filter(doc => doc.data().status === 'active').length,
        inactive: querySnapshot.docs.filter(doc => doc.data().status === 'inactive').length
      };
      
      console.log('‚úÖ Estat√≠sticas calculadas:', stats);
      return { data: stats };
    } catch (error) {
      console.error('‚ùå Erro ao calcular estat√≠sticas:', error);
      return { data: { total: 0, active: 0, inactive: 0 } };
    }
  },

  getMemberContributions: async (id: string, params?: any) => {
    return { data: { contributions: [] } };
  }
};

// API para categorias (usando Firebase Firestore)
export const categoriesAPI = {
  getCategories: async () => {
    try {
      console.log('üî• Buscando categorias no Firestore...');
      const categoriesRef = collection(db, 'categories');
      const querySnapshot = await getDocs(categoriesRef);
      
      const categories = querySnapshot.docs.map(doc => ({
        id: parseInt(doc.id) || Math.random() * 1000000, // Converter para number
        name: doc.data().name || 'Categoria n√£o informada',
        type: doc.data().type || 'income',
        color: doc.data().color || '#3B82F6',
        created_at: doc.data().created_at || new Date(),
        updated_at: doc.data().updated_at || new Date()
      }));
      
      // Se n√£o h√° categorias salvas, criar algumas padr√£o
      if (categories.length === 0) {
        console.log('üìù Criando categorias padr√£o...');
        const defaultCategories = [
          { name: 'D√≠zimos', type: 'income', description: 'D√≠zimos dos membros', color: '#10B981' },
          { name: 'Ofertas', type: 'income', description: 'Ofertas especiais', color: '#3B82F6' },
          { name: 'Utilidades', type: 'expense', description: 'Contas de √°gua, luz, telefone', color: '#EF4444' },
          { name: 'Manuten√ß√£o', type: 'expense', description: 'Manuten√ß√£o do pr√©dio', color: '#F97316' }
        ];
        
        for (const category of defaultCategories) {
          await addDoc(categoriesRef, {
            ...category,
            created_at: new Date(),
            updated_at: new Date()
          });
        }
        
        // Buscar novamente ap√≥s criar as categorias padr√£o
        const newQuerySnapshot = await getDocs(categoriesRef);
        const newCategories = newQuerySnapshot.docs.map(doc => ({
          id: parseInt(doc.id) || Math.random() * 1000000, // Converter para number
          name: doc.data().name || 'Categoria n√£o informada',
          type: doc.data().type || 'income',
          color: doc.data().color || '#3B82F6',
          created_at: doc.data().created_at || new Date(),
          updated_at: doc.data().updated_at || new Date()
        }));
        
        console.log('‚úÖ Categorias padr√£o criadas:', newCategories.length);
        return { data: { categories: newCategories, total: newCategories.length } };
      }
      
      console.log('‚úÖ Categorias carregadas do Firestore:', categories.length);
      return { data: { categories, total: categories.length } };
    } catch (error) {
      console.error('‚ùå Erro ao buscar categorias:', error);
      return { data: { categories: [], total: 0 } };
    }
  },

  createCategory: async (data: any) => {
    try {
      console.log('üíæ Salvando categoria no Firestore:', data);
      
      const categoryData = {
        ...data,
        created_at: new Date(),
        updated_at: new Date()
      };
      
      const categoriesRef = collection(db, 'categories');
      const docRef = await addDoc(categoriesRef, categoryData);
      
      console.log('‚úÖ Categoria salva no Firestore com ID:', docRef.id);
      
      return {
        data: {
          message: 'Categoria criada com sucesso',
          category: { id: docRef.id, ...categoryData }
        }
      };
    } catch (error) {
      console.error('‚ùå Erro ao criar categoria:', error);
      toast.error('Erro ao salvar categoria');
      throw error;
    }
  },

  updateCategory: async (id: string, data: any) => {
    try {
      console.log('üîÑ Atualizando categoria no Firestore:', id);
      
      const categoryRef = doc(db, 'categories', id);
      await updateDoc(categoryRef, {
        ...data,
        updated_at: new Date()
      });
      
      console.log('‚úÖ Categoria atualizada no Firestore');
      return { data: { message: 'Categoria atualizada com sucesso' } };
    } catch (error) {
      console.error('‚ùå Erro ao atualizar categoria:', error);
      toast.error('Erro ao atualizar categoria');
      throw error;
    }
  },

  deleteCategory: async (id: string) => {
    try {
      console.log('üóëÔ∏è Deletando categoria do Firestore:', id);
      
      const categoryRef = doc(db, 'categories', id);
      await deleteDoc(categoryRef);
      
      console.log('‚úÖ Categoria deletada do Firestore');
      return { data: { message: 'Categoria deletada com sucesso' } };
    } catch (error) {
      console.error('‚ùå Erro ao deletar categoria:', error);
      toast.error('Erro ao deletar categoria');
      throw error;
    }
  },

  getCategory: async (id: string) => {
    try {
      const categoriesRef = collection(db, 'categories');
      const querySnapshot = await getDocs(categoriesRef);
      const category = querySnapshot.docs.find(doc => doc.id === id);
      
      if (!category) {
        throw new Error('Categoria n√£o encontrada');
      }
      
      return { data: { id: category.id, ...category.data() } };
    } catch (error) {
      console.error('‚ùå Erro ao buscar categoria:', error);
      throw error;
    }
  },

  getCategoryStats: async (params?: any) => {
    return { data: { stats: {} } };
  }
};

// APIs de compatibilidade
export const authAPI = {
  login: async (username: string, password: string) => {
    throw new Error('Use Firebase Auth diretamente');
  },
  register: async (username: string, email: string, password: string) => {
    throw new Error('Use Firebase Auth diretamente');
  },
  verifyToken: async () => {
    throw new Error('Use Firebase Auth diretamente');
  },
  getProfile: async () => {
    throw new Error('Use Firebase Auth diretamente');
  },
  changePassword: async (currentPassword: string, newPassword: string) => {
    throw new Error('Use Firebase Auth diretamente');
  }
};

export const usersAPI = {
  getUsers: async () => {
    return { data: { users: [] } };
  },
  createUser: async (data: any) => {
    return { data: { message: 'Use Firebase Auth' } };
  },
  deleteUser: async (id: string) => {
    return { data: { message: 'Use Firebase Auth' } };
  }
};

export const reportsAPI = {
  getMonthlyBalance: async (year: number, month: number) => {
    return { data: { balance: 0 } };
  },
  getYearlyBalance: async (year: number) => {
    return { data: { balance: 0 } };
  },
  getMemberContributions: async (params?: any) => {
    return { data: { contributions: [] } };
  },
  getIncomeByCategory: async (params?: any) => {
    return { data: { income: [] } };
  },
  getExpenseByCategory: async (params?: any) => {
    return { data: { expenses: [] } };
  },
  getCashFlow: async (params?: any) => {
    return { data: { cashFlow: [] } };
  },
  getTopContributors: async (params?: any) => {
    return { data: { contributors: [] } };
  }
};

export default {
  transactionsAPI,
  membersAPI,
  categoriesAPI,
  authAPI,
  usersAPI,
  reportsAPI
}